---
layout: post
status: publish
published: true
title: Override the IEnumerable Mapper in Glass.Mapper 4.0
author:
  display_name: admin_rolspace
  login: admin_rolspace
  email: rolandorramos@gmail.com
  url: ''
author_login: admin_rolspace
author_email: rolandorramos@gmail.com
excerpt: "A few weeks ago I needed to write&nbsp;a specific implementation of the
  mapper&nbsp;used in Glass.Mapper to handle <em>IEnumerable<T><&#47;em> Types. This
  was necessary because the Sitecore instance&nbsp;I was working with had&nbsp;a customized
  implementation&nbsp;for handling language fallbacks. This did not play well with
  the default Glass.Mapper implementation.\r\n\r\nI had to come up with a way to modify
  how Glass.Mapper handles fields that map to an <em>IEnumerable<T><&#47;em> type,
  such as Multilists or Treelists. This is what I did.\r\n\r\nTo get started, I needed&nbsp;to
  create a custom attribute class that would allow me to specify a custom type&nbsp;mapper.&nbsp;The
  custom attribute could be used like&nbsp;this on type that needed this behavior:\r\n<pre
  class=\"lang:c# decode:true\">public class Model\r\n{\r\n    [CustomIEnumerable]\r\n
  \   public virtual IEnumerable<CollectionItem> Collection { get; set; }\r\n}<&#47;pre>\r\n"
wordpress_id: 674
wordpress_url: http://www.rolspace.com/?p=674
date: '2015-07-12 21:54:16 +0200'
date_gmt: '2015-07-12 21:54:16 +0200'
categories:
- Uncategorized
tags: []
comments: []
---
<p>A few weeks ago I needed to write&nbsp;a specific implementation of the mapper&nbsp;used in Glass.Mapper to handle <em>IEnumerable<T><&#47;em> Types. This was necessary because the Sitecore instance&nbsp;I was working with had&nbsp;a customized implementation&nbsp;for handling language fallbacks. This did not play well with the default Glass.Mapper implementation.</p>
<p>I had to come up with a way to modify how Glass.Mapper handles fields that map to an <em>IEnumerable<T><&#47;em> type, such as Multilists or Treelists. This is what I did.</p>
<p>To get started, I needed&nbsp;to create a custom attribute class that would allow me to specify a custom type&nbsp;mapper.&nbsp;The custom attribute could be used like&nbsp;this on type that needed this behavior:</p>
<pre class="lang:c# decode:true">public class Model<br />
{<br />
    [CustomIEnumerable]<br />
    public virtual IEnumerable<CollectionItem> Collection { get; set; }<br />
}<&#47;pre><br />
<a id="more"></a><a id="more-674"></a>This custom attribute will&nbsp;map to a field similar to the one shown in this image:</p>
<p><img class="aligncenter size-full wp-image-676" style="border-radius: 0px;" src="http:&#47;&#47;www.rolspace.com&#47;wp-content&#47;uploads&#47;2015&#47;07&#47;collectionfield.png" alt="" width="724" height="255" &#47;></p>
<p>In order to create this custom attribute, it is&nbsp;necessary to inherit from the&nbsp;<em>SitecoreFieldAttribute<&#47;em> class from the&nbsp;Glass.Mapper.Sc.Configuration.Attributes namespace. In this scenario, the&nbsp;<em>Configure<&#47;em> method from the SitecoreFieldAttribute class must be overridden to setup the Attribute's configuration:</p>
<pre class="lang:c# decode:true">public class CustomIEnumerableAttribute : SitecoreFieldAttribute<br />
{<br />
    public CustomIEnumerableAttribute()<br />
        : base() { }</p>
<p>    public CustomIEnumerableAttribute(string fieldName)<br />
        : base(fieldName) { }</p>
<p>    public CustomIEnumerableAttribute(string fieldId, SitecoreFieldType fieldType,<br />
        string sectionName, bool codeFirst)<br />
        : base(fieldId, fieldType, sectionName, codeFirst) { }</p>
<p>    public override AbstractPropertyConfiguration Configure(PropertyInfo propertyInfo)<br />
    {<br />
        var config = new CustomIEnumerableConfiguration();<br />
        this.Configure(propertyInfo, config);</p>
<p>        return config;<br />
    }<br />
}<&#47;pre><br />
The <em>Configure<&#47;em> method of our <em>CustomIEnumerableAttribute<&#47;em> requires an object of type <em>AbstractPropertyConfiguration<&#47;em>, which we do not have yet. I will create a new class called <em>CustomIEnumerableConfiguration<&#47;em> which inherits from <em>SitecoreFieldConfiguration<&#47;em>, which in turn inherits from <em>AbstractPropertyConfiguration<&#47;em>. This way I can avoid writing a full implementation, when I only need to override the <em>Copy<&#47;em> method from the <em>SitecoreFieldConfiguration<&#47;em> class:</p>
<pre class="lang:c# decode:true">public class CustomIEnumerableConfiguration : SitecoreFieldConfiguration<br />
{<br />
    public override SitecoreFieldConfiguration Copy()<br />
    {<br />
        return new CustomIEnumerableConfiguration<br />
        {<br />
            CodeFirst = this.CodeFirst,<br />
            FieldId = this.FieldId,<br />
            FieldName = this.FieldName,<br />
            FieldSource = this.FieldSource,<br />
            FieldTitle = this.FieldTitle,<br />
            FieldType = this.FieldType,<br />
            IsShared = this.IsShared,<br />
            IsUnversioned = this.IsUnversioned,<br />
            PropertyInfo = this.PropertyInfo,<br />
            ReadOnly = this.ReadOnly,<br />
            SectionName = this.SectionName,<br />
            Setting = this.Setting<br />
        };<br />
    }<br />
}<&#47;pre><br />
Since the CustomIEnumerableConfiguration class is complete, then the CustomIEnumerableAttribute class is completed as well. Now the&nbsp;final piece of the puzzle is the custom type mapper class I need to implement.</p>
<p>For this, I&nbsp;will inherit from the <em>AbstractSitecoreFieldMapper<&#47;em> class in the&nbsp;Glass.Mapper.Sc.DataMappers namespace. This is the base class from which all mappers in Glass.Mapper&nbsp;assembly inherit.</p>
<p>The implementation for the <em>CustomIEnumerableMapper<&#47;em> class is shown below. For the purpose of this post I have borrowed the implementation from the <em>SitecoreFieldIEnumerableMapper<&#47;em> class used by Glass.Mapper.</p>
<p>I have only added a few lines of code, in order to write to the Sitecore Log and&nbsp;demonstrate the use of the custom type mapper class:</p>
<pre class="tab-size:3 lang:c# decode:true ">public class CustomIEnumerableMapper : AbstractSitecoreFieldMapper<br />
{<br />
   public override object GetFieldValue(string fieldValue,<br />
      SitecoreFieldConfiguration config, SitecoreDataMappingContext context)<br />
   {<br />
      Type genericArgument =<br />
         Glass.Mapper.Utilities.GetGenericArgument(config.PropertyInfo.PropertyType);</p>
<p>      &#47;&#47;Write to the Sitecore Log<br />
      Sitecore.Diagnostics.Log.Info(<br />
         string.Format("Mapping Type: {0}", genericArgument), this);</p>
<p>      IEnumerable<object> enumerable = (IEnumerable<object>)Enumerable.ToArray<object>(<br />
         Enumerable.Select<string, object>(<br />
            (IEnumerable<string>)Enumerable.ToArray<string>(<br />
               Enumerable.Select<string, string>(<br />
                  (IEnumerable<string>)fieldValue.Split(<br />
                     new char[1] { '|' }, StringSplitOptions.RemoveEmptyEntries),<br />
                  (Func<string, string>)(x => x.Replace(Global.PipeEncoding, "|")))),<br />
                  (Func<string, object>)(x => Context.Database.GetItem(new ID(x)))));</p>
<p>      IList list = Glass.Mapper.Sc.Utilities.CreateGenericType(typeof(List<>),<br />
         new Type[1] { genericArgument }) as IList;</p>
<p>      foreach (object obj in enumerable)<br />
      {<br />
         if (obj != null)<br />
            list.Add(context.Service.CreateType(<br />
              genericArgument, (Item)obj, false, false, null));<br />
      }</p>
<p>      return (object)list;<br />
    }</p>
<p>   public override string SetFieldValue(object value,<br />
      SitecoreFieldConfiguration config, SitecoreDataMappingContext context)<br />
   {<br />
      IEnumerable enumerable = value as IEnumerable;<br />
      if (enumerable == null)<br />
         return (string) null;</p>
<p>      List<string> list = new List<string>();<br />
      foreach (object obj in enumerable)<br />
      {<br />
         string str = this.Mapper.SetFieldValue(obj, config, context);<br />
         if (!ExtensionMethods.IsNullOrEmpty(str))<br />
            list.Add(str);<br />
      }</p>
<p>      Type genericArgument =<br />
         Glass.Mapper.Utilities.GetGenericArgument(config.PropertyInfo.PropertyType);</p>
<p>      &#47;&#47;Write to the Sitecore Log<br />
      Sitecore.Diagnostics.Log.Info(<br />
         string.Format("Storing Type: {0}", genericArgument), this);</p>
<p>      if (Enumerable.Any<string>((IEnumerable<string>) list))<br />
         return Enumerable.Aggregate<string>((IEnumerable<string>) list,<br />
            (Func<string, string, string>) ((x, y) => x + "|" + y));</p>
<p>      return (string) null;<br />
   }</p>
<p>   public override bool CanHandle(AbstractPropertyConfiguration configuration,<br />
      Glass.Mapper.Context context)<br />
   {<br />
      return configuration is CustomIEnumerableConfiguration;<br />
   }<br />
}<&#47;pre><br />
There are three methods that need to be overridden in order to properly implement our custom <em>IEnumerable<T><&#47;em> type mapper:</p>
<ul>
<li style="margin-bottom: 10px;"><span style="text-decoration: underline;">GetFieldValue<&#47;span>: this method will obtain the field's value in raw format and convert each of the referenced items to the generic type used in&nbsp;the <em>IEnumerable<T><&#47;em>.<&#47;li>
<li style="margin-bottom: 10px;"><span style="text-decoration: underline;">SetFieldValue<&#47;span>: as the name implies, this method will take the value of the <em>IEnumerable<T><&#47;em>&nbsp;instance and store it in the field.<&#47;li>
<li><span style="text-decoration: underline;">CanHandle<&#47;span>: this method defines&nbsp;a condition to determine if&nbsp;the custom mapper can be used. In our scenario there is one rule only: apply&nbsp;the custom mapper if&nbsp;the configuration parameter&nbsp;is of type <em>CustomIEnumerableConfiguration<&#47;em>.<&#47;li><br />
<&#47;ul><br />
Once this is all completed, it is possible to include this type mapper in the <em>CreateResolverMethod<&#47;em> of the&nbsp;<em>GlassMapperScCustom<&#47;em> class:</p>
<pre class="lang:c# decode:true">public static IDependencyResolver CreateResolver()<br />
{<br />
    var config = new Glass.Mapper.Sc.Config();<br />
    var container = new Castle.Windsor.WindsorContainer();</p>
<p>    container.Register(<br />
        Component.For<AbstractDataMapper>()<br />
            .ImplementedBy<CustomFieldMapper>().LifestyleTransient(),<br />
        Component.For<AbstractDataMapper>()<br />
            .ImplementedBy<CustomIEnumerableMapper>().LifestyleTransient()<br />
    );</p>
<p>    container.Install(new Glass.Mapper.Sc.CastleWindsor.WindsorSitecoreInstaller(config));</p>
<p>    var resolver = new Glass.Mapper.Sc.CastleWindsor.DependencyResolver(container);</p>
<p>    return resolver;<br />
}<&#47;pre><br />
After this code is deployed to the Sitecore instance, it is easy to determine that the&nbsp;code used in the <em>CustomIEnumerableMapper<&#47;em> class is being executed:</p>
<p><a href="http:&#47;&#47;www.rolspace.com&#47;wp-content&#47;uploads&#47;2015&#47;07&#47;overrideienumerable.png"><img class="aligncenter size-full wp-image-764" src="http:&#47;&#47;www.rolspace.com&#47;wp-content&#47;uploads&#47;2015&#47;07&#47;overrideienumerable.png" alt="" width="672" height="106" &#47;><&#47;a></p>
<p>As a final note, it is important to point out that this approach will work if you are using Glass.Mapper v4 together with the <em>Glass.Mapper.Sc.CastleWindsor<&#47;em> v4 assembly in your solution.</p>
<p>Unfortunately, I have not been able to test this functionality in Glass.Mapper.Sc v4 using a different IoC container. However, the code provided here serves as a good starting point for anyone trying to achieve something similar.</p>
